name: CI/CD - mall-maintenance (DEV)

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.github/workflows/bootstrap-*.yaml'
      - '.github/workflows/diagnostics-*.yaml'
  workflow_dispatch:

env:
  APP_NAME: mall-maintenance
  TENANT: opsera
  ENVIRONMENT: dev
  AWS_REGION: us-west-2
  SPOKE_CLUSTER: opsera-usw2-np
  NAMESPACE: opsera-mall-maintenance-dev

# RULE 148: Required permissions
permissions:
  contents: write
  id-token: write

jobs:
  # Stage 1: Security Scan
  security-scan:
    name: Security Scan - Gitleaks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

  # Stage 2: Build, Scan & Push
  build-and-push:
    name: Build, Scan & Push Docker Image
    runs-on: ubuntu-latest
    needs: [security-scan]
    if: success() || needs.security-scan.result == 'skipped'
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      ecr_uri: ${{ steps.meta.outputs.ecr_uri }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Generate Image Metadata
        id: meta
        run: |
          # RULE 147: Get AWS_ACCOUNT_ID dynamically
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${APP_NAME}"

          # RULE 175: Immutable ECR tags (no -latest suffix)
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-8)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          IMAGE_TAG="${ENVIRONMENT}-${SHORT_SHA}-${TIMESTAMP}"

          echo "ecr_uri=${ECR_URI}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT

          echo "ðŸ“¦ Image: ${ECR_URI}:${IMAGE_TAG}"

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${{ steps.meta.outputs.ecr_uri }}

      - name: Build Docker Image
        run: |
          docker build -t ${{ steps.meta.outputs.ecr_uri }}:${{ steps.meta.outputs.image_tag }} .
          echo "âœ… Image built successfully"

      - name: Run Grype Security Scan
        uses: anchore/scan-action@v4
        with:
          image: ${{ steps.meta.outputs.ecr_uri }}:${{ steps.meta.outputs.image_tag }}
          fail-build: false
          severity-cutoff: high
        continue-on-error: true

      - name: Push Image to ECR
        run: |
          docker push ${{ steps.meta.outputs.ecr_uri }}:${{ steps.meta.outputs.image_tag }}
          echo "âœ… Image pushed to ECR"

  # Stage 3: Update Manifests
  update-manifests:
    name: Update Kubernetes Manifests
    runs-on: ubuntu-latest
    needs: [build-and-push]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update Kustomization
        run: |
          # RULE 147: Get AWS_ACCOUNT_ID dynamically in EACH job
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${APP_NAME}"
          IMAGE_TAG="${{ needs.build-and-push.outputs.image_tag }}"

          cd .opsera-${APP_NAME}/k8s/overlays/${ENVIRONMENT}

          # RULE 131: Safety - replace any remaining PLACEHOLDER_ECR_URI (idempotent)
          sed -i "s|PLACEHOLDER_ECR_URI|${ECR_URI}|g" kustomization.yaml

          # Update image tag
          sed -i "s|newName:.*|newName: ${ECR_URI}|g" kustomization.yaml
          sed -i "s|newTag:.*|newTag: ${IMAGE_TAG}|g" kustomization.yaml

          echo "âœ… Updated kustomization.yaml with image: ${ECR_URI}:${IMAGE_TAG}"

          cat kustomization.yaml

      - name: Commit and Push Changes
        run: |
          git config --global user.name "Opsera Bot"
          git config --global user.email "bot@opsera.io"

          # RULE 143: Pull first, then changes, then commit/push
          git pull --rebase origin main

          git add .opsera-${APP_NAME}/k8s/overlays/${ENVIRONMENT}/kustomization.yaml

          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            # RULE 111: Heredoc for commit messages
            git commit -m "$(cat <<EOF
deploy: Update ${ENVIRONMENT} image to ${{ needs.build-and-push.outputs.image_tag }}

Environment: ${ENVIRONMENT}
Image: ${{ needs.build-and-push.outputs.ecr_uri }}:${{ needs.build-and-push.outputs.image_tag }}
Commit: ${{ github.sha }}

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
EOF
)"
            git push origin main
            echo "âœ… Manifests pushed to repository"
          fi

  # Stage 4: Refresh ECR Secret
  refresh-ecr-secret:
    name: Refresh ECR Pull Secret
    runs-on: ubuntu-latest
    needs: [update-manifests]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v4

      - name: Setup Kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_SPOKE }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Refresh ECR Secret
        run: |
          # RULE 163: ECR tokens expire after 12 hours
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_TOKEN=$(aws ecr get-login-password --region ${AWS_REGION})

          kubectl create secret docker-registry ecr-pull-secret \
            --docker-server="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com" \
            --docker-username=AWS \
            --docker-password="${ECR_TOKEN}" \
            --namespace="${NAMESPACE}" \
            --dry-run=client -o yaml | kubectl apply -f -

          echo "âœ… ECR secret refreshed"

  # Stage 5: Sync ArgoCD
  sync-argocd:
    name: Sync ArgoCD Application
    runs-on: ubuntu-latest
    needs: [refresh-ecr-secret]
    steps:
      - name: Install kubectl
        uses: azure/setup-kubectl@v4

      - name: Setup Kubeconfig for Hub
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_HUB }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Force ArgoCD Sync
        run: |
          APP="${APP_NAME}-${ENVIRONMENT}"

          # RULE 93: Use kubectl for ArgoCD operations
          kubectl patch application ${APP} -n argocd \
            --type merge \
            -p '{"operation": {"initiatedBy": {"username": "github-actions"}, "sync": {"revision": "main"}}}'

          echo "âœ… ArgoCD sync initiated for ${APP}"

          # Wait for sync to complete
          echo "Waiting for sync to complete..."
          for i in {1..30}; do
            SYNC_STATUS=$(kubectl get application ${APP} -n argocd -o jsonpath='{.status.sync.status}')
            HEALTH_STATUS=$(kubectl get application ${APP} -n argocd -o jsonpath='{.status.health.status}')

            echo "Sync: ${SYNC_STATUS}, Health: ${HEALTH_STATUS}"

            if [ "${SYNC_STATUS}" = "Synced" ]; then
              echo "âœ… Application synced successfully"
              break
            fi

            sleep 10
          done

  # Stage 6: Verify Deployment
  verify-deployment:
    name: Verify Deployment Health
    runs-on: ubuntu-latest
    needs: [sync-argocd, build-and-push]
    steps:
      - name: Install kubectl
        uses: azure/setup-kubectl@v4

      - name: Setup Kubeconfig for Spoke
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_SPOKE }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Wait for Deployment Rollout
        run: |
          echo "Waiting for deployment to be ready..."
          kubectl rollout status deployment/${APP_NAME} -n ${NAMESPACE} --timeout=5m

          echo "âœ… Deployment rolled out successfully"

      - name: Verify Pods
        run: |
          echo "Checking pod status..."
          kubectl get pods -n ${NAMESPACE} -l app=${APP_NAME}

          # Wait for all pods to be ready
          kubectl wait --for=condition=ready pod -l app=${APP_NAME} -n ${NAMESPACE} --timeout=300s

          echo "âœ… All pods are ready"

      - name: Health Check via Port-Forward
        run: |
          # RULE 168: Health checks MUST use port-forward
          POD=$(kubectl get pod -n ${NAMESPACE} -l app=${APP_NAME} -o jsonpath='{.items[0].metadata.name}')

          echo "Running health check on pod: ${POD}"

          # Start port-forward in background
          kubectl port-forward -n ${NAMESPACE} ${POD} 8081:8080 &
          PF_PID=$!

          # Wait for tunnel to establish
          sleep 3

          # Test the health endpoint
          if wget -qO- http://localhost:8081/ > /dev/null 2>&1; then
            echo "âœ… Health check passed"
          else
            echo "âŒ Health check failed"
            kill $PF_PID 2>/dev/null || true
            exit 1
          fi

          # Cleanup
          kill $PF_PID 2>/dev/null || true

      - name: Verify Service and Ingress
        run: |
          echo "Service status:"
          kubectl get service ${APP_NAME} -n ${NAMESPACE}

          echo "Ingress status:"
          kubectl get ingress ${APP_NAME} -n ${NAMESPACE}

          echo "âœ… Service and Ingress verified"

  # Stage 7: Deployment Summary
  deployment-summary:
    name: Generate Deployment Summary
    runs-on: ubuntu-latest
    needs: [verify-deployment, build-and-push]
    if: always()
    steps:
      - name: Generate Summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # ðŸš€ Deployment Summary - mall-maintenance (DEV)

          ## Image Details

          | Property | Value |
          |----------|-------|
          | Image Tag | \`${{ needs.build-and-push.outputs.image_tag }}\` |
          | ECR URI | \`${{ needs.build-and-push.outputs.ecr_uri }}\` |
          | Commit | \`${{ github.sha }}\` |

          ## Deployment Status

          | Stage | Status |
          |-------|--------|
          | Security Scan | ${{ needs.security-scan.result == 'success' && 'âœ…' || 'âš ï¸' }} |
          | Build & Push | ${{ needs.build-and-push.result == 'success' && 'âœ…' || 'âŒ' }} |
          | Update Manifests | ${{ needs.update-manifests.result == 'success' && 'âœ…' || 'âŒ' }} |
          | Refresh ECR Secret | ${{ needs.refresh-ecr-secret.result == 'success' && 'âœ…' || 'âŒ' }} |
          | Sync ArgoCD | ${{ needs.sync-argocd.result == 'success' && 'âœ…' || 'âŒ' }} |
          | Verify Deployment | ${{ needs.verify-deployment.result == 'success' && 'âœ…' || 'âŒ' }} |

          ## Access Points

          - **Application URL**: http://mall-maintenance-dev.agent.opsera.dev
          - **ArgoCD**: https://argocd-usw2.agent.opsera.dev
          - **Namespace**: \`${NAMESPACE}\`

          ---
          *Powered by Opsera Code-to-Cloud Enterprise v0.922*
          EOF
