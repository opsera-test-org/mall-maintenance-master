name: "[C2C] CI/CD Pipeline - mall-maintenance-dev"

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.github/workflows/c2c-bootstrap-*.yml'
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests'
        required: false
        default: 'false'
        type: choice
        options:
        - 'true'
        - 'false'
      grype_mode:
        description: 'Grype scan mode'
        required: false
        default: 'warn'
        type: choice
        options:
        - 'warn'
        - 'block'

env:
  APP_NAME: mall-maintenance
  TENANT: opsera
  ENVIRONMENT: dev
  NAMESPACE: opsera-mall-maintenance-dev
  AWS_REGION: us-west-2
  REGION_SHORT: usw2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  ARGOCD_SERVER: argocd-usw2.agent.opsera.dev
  ECR_REPO_NAME: opsera/mall-maintenance
  DOMAIN: agent.opsera.dev

jobs:
  # ============================================================================
  # STAGE 1: GITLEAKS SECURITY SCAN (Warn-Only by Default)
  # ============================================================================
  gitleaks-scan:
    name: "Stage 1: Gitleaks Security Scan"
    runs-on: ubuntu-latest
    continue-on-error: true  # Warn-only mode (RULE 205)
    permissions:
      contents: read
      security-events: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Run Gitleaks
      uses: gitleaks/gitleaks-action@v2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload Gitleaks results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: gitleaks-report
        path: results.sarif
        retention-days: 30

  # ============================================================================
  # STAGE 2: BUILD DOCKER IMAGE (Local Build, No Push)
  # ============================================================================
  build-image:
    name: "Stage 2: Build Docker Image"
    runs-on: ubuntu-latest
    needs: [gitleaks-scan]
    if: always() && needs.gitleaks-scan.result != 'cancelled'
    outputs:
      image_tag: ${{ steps.gen_tag.outputs.image_tag }}
      short_sha: ${{ steps.gen_tag.outputs.short_sha }}
      timestamp: ${{ steps.gen_tag.outputs.timestamp }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Generate unique image tag
      id: gen_tag
      run: |
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
        echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
        echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
        echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
        echo "Generated image tag: ${IMAGE_TAG}"

    - name: Build Docker image (local only)
      run: |
        docker build \
          --file .${TENANT}-${APP_NAME}/Dockerfile \
          --tag ${APP_NAME}:${{ steps.gen_tag.outputs.image_tag }} \
          --tag ${APP_NAME}:local \
          --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
          --build-arg VCS_REF=${{ github.sha }} \
          --build-arg VERSION=${{ steps.gen_tag.outputs.image_tag }} \
          .

    - name: Save Docker image as artifact
      run: |
        docker save ${APP_NAME}:${{ steps.gen_tag.outputs.image_tag }} | gzip > ${APP_NAME}-${{ steps.gen_tag.outputs.image_tag }}.tar.gz

    - name: Upload Docker image artifact
      uses: actions/upload-artifact@v4
      with:
        name: docker-image
        path: ${{ env.APP_NAME }}-${{ steps.gen_tag.outputs.image_tag }}.tar.gz
        retention-days: 1

  # ============================================================================
  # STAGE 3: GRYPE VULNERABILITY SCAN (Before Push)
  # ============================================================================
  grype-scan:
    name: "Stage 3: Grype Vulnerability Scan"
    runs-on: ubuntu-latest
    needs: [build-image]
    continue-on-error: true  # Warn-only mode by default
    permissions:
      contents: read
      security-events: write

    steps:
    - name: Download Docker image artifact
      uses: actions/download-artifact@v4
      with:
        name: docker-image

    - name: Load Docker image
      run: |
        gunzip -c ${APP_NAME}-${{ needs.build-image.outputs.image_tag }}.tar.gz | docker load

    - name: Run Grype vulnerability scan
      uses: anchore/scan-action@v4
      id: grype_scan
      with:
        image: "${{ env.APP_NAME }}:${{ needs.build-image.outputs.image_tag }}"
        fail-build: false  # Controlled by continue-on-error
        severity-cutoff: high
        output-format: sarif

    - name: Upload Grype results to GitHub Security
      if: always()
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: ${{ steps.grype_scan.outputs.sarif }}

    - name: Upload Grype results as artifact
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: grype-report
        path: ${{ steps.grype_scan.outputs.sarif }}
        retention-days: 30

  # ============================================================================
  # STAGE 4: PUSH TO ECR (Only if Build Succeeded)
  # ============================================================================
  push-to-ecr:
    name: "Stage 4: Push to ECR"
    runs-on: ubuntu-latest
    needs: [build-image, grype-scan]
    if: always() && needs.build-image.result == 'success'
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get AWS Account ID
      id: aws_account
      run: |
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT
        echo "AWS Account: ${AWS_ACCOUNT_ID}"

    - name: Login to Amazon ECR
      id: login_ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Download Docker image artifact
      uses: actions/download-artifact@v4
      with:
        name: docker-image

    - name: Load Docker image
      run: |
        gunzip -c ${APP_NAME}-${{ needs.build-image.outputs.image_tag }}.tar.gz | docker load

    - name: Tag and push to ECR
      run: |
        AWS_ACCOUNT_ID=${{ steps.aws_account.outputs.account_id }}
        ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"
        IMAGE_TAG=${{ needs.build-image.outputs.image_tag }}

        docker tag ${APP_NAME}:${IMAGE_TAG} ${ECR_URI}:${IMAGE_TAG}
        docker push ${ECR_URI}:${IMAGE_TAG}

        echo "‚úì Image pushed: ${ECR_URI}:${IMAGE_TAG}"
        echo "ECR_URI=${ECR_URI}" >> $GITHUB_ENV
        echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV

  # ============================================================================
  # STAGE 5: REFRESH ECR SECRET (SPOKE Cluster - Before Manifests)
  # ============================================================================
  refresh-ecr-secret:
    name: "Stage 5: Refresh ECR Secret"
    runs-on: ubuntu-latest
    needs: [push-to-ecr]
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3

    - name: Configure SPOKE cluster kubeconfig
      run: |
        aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke
        kubectl config use-context spoke

    - name: Get AWS Account ID
      id: aws_account
      run: |
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT

    - name: Get ECR login token
      id: ecr_token
      run: |
        ECR_TOKEN=$(aws ecr get-login-password --region ${AWS_REGION})
        echo "::add-mask::${ECR_TOKEN}"
        echo "token=${ECR_TOKEN}" >> $GITHUB_OUTPUT

    - name: Create/Update ECR pull secret
      run: |
        AWS_ACCOUNT_ID=${{ steps.aws_account.outputs.account_id }}
        ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

        kubectl delete secret ecr-pull-secret -n ${NAMESPACE} --ignore-not-found

        kubectl create secret docker-registry ecr-pull-secret \
          --docker-server=${ECR_REGISTRY} \
          --docker-username=AWS \
          --docker-password=${{ steps.ecr_token.outputs.token }} \
          --namespace=${NAMESPACE}

        echo "‚úì ECR pull secret refreshed in ${NAMESPACE}"

  # ============================================================================
  # STAGE 6: UPDATE KUSTOMIZE MANIFESTS (Idempotent Git Operations)
  # ============================================================================
  update-manifests:
    name: "Stage 6: Update Manifests"
    runs-on: ubuntu-latest
    needs: [push-to-ecr, refresh-ecr-secret]
    permissions:
      contents: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GH_PAT }}
        fetch-depth: 0

    - name: Configure Git
      run: |
        git config user.name "opsera-bot"
        git config user.email "bot@opsera.io"

    - name: Get AWS Account ID
      id: aws_account
      run: |
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text 2>/dev/null || echo "PLACEHOLDER")
        echo "account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT

    - name: Update kustomization.yaml
      run: |
        AWS_ACCOUNT_ID=${{ steps.aws_account.outputs.account_id }}
        ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"
        IMAGE_TAG=${{ needs.build-image.outputs.image_tag }}
        OVERLAY_PATH=".${TENANT}-${APP_NAME}/k8s/overlays/${ENVIRONMENT}"

        cd ${OVERLAY_PATH}

        # Update newName and newTag in kustomization.yaml (RULE 234)
        if [ -f kustomization.yaml ]; then
          # Update newName
          sed -i.bak "s|newName:.*|newName: ${ECR_URI}|g" kustomization.yaml

          # Update newTag
          sed -i.bak "s|newTag:.*|newTag: ${IMAGE_TAG}|g" kustomization.yaml

          rm -f kustomization.yaml.bak

          echo "‚úì Updated kustomization.yaml:"
          cat kustomization.yaml
        else
          echo "‚ùå kustomization.yaml not found"
          exit 1
        fi

    - name: Commit and push changes (idempotent)
      run: |
        # Pull latest changes first
        git pull --rebase origin main

        # Check if there are changes to commit
        if git diff --quiet; then
          echo "‚úì No changes to commit"
          exit 0
        fi

        # Commit and push
        git add .${TENANT}-${APP_NAME}/k8s/overlays/${ENVIRONMENT}/kustomization.yaml
        git commit -m "chore: Update ${ENVIRONMENT} image to ${{ needs.build-image.outputs.image_tag }} [skip ci]

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

        # Push with retry on conflict
        MAX_RETRIES=3
        for i in $(seq 1 $MAX_RETRIES); do
          if git push origin main; then
            echo "‚úì Changes pushed successfully"
            exit 0
          else
            echo "Push failed, retrying... ($i/$MAX_RETRIES)"
            git pull --rebase origin main
          fi
        done

        echo "‚ùå Failed to push after $MAX_RETRIES attempts"
        exit 1

  # ============================================================================
  # STAGE 7: CREATE/UPDATE ARGOCD APPLICATION (NEW v2.4 - Idempotent)
  # ============================================================================
  create-argocd-app:
    name: "Stage 7: Create/Update ArgoCD App"
    runs-on: ubuntu-latest
    needs: [update-manifests]
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3

    - name: Configure HUB cluster kubeconfig
      run: |
        aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub
        kubectl config use-context hub

    - name: Create/Update ArgoCD Application
      run: |
        APP_FILE=".${TENANT}-${APP_NAME}/argocd/${ENVIRONMENT}/application.yaml"

        if [ ! -f "$APP_FILE" ]; then
          echo "‚ùå ArgoCD application file not found: ${APP_FILE}"
          exit 1
        fi

        # Apply application (idempotent)
        kubectl apply -f ${APP_FILE}

        echo "‚úì ArgoCD application created/updated: ${APP_NAME}-${ENVIRONMENT}"

  # ============================================================================
  # STAGE 8: ARGOCD HARD REFRESH (HUB Cluster)
  # ============================================================================
  argocd-refresh:
    name: "Stage 8: ArgoCD Hard Refresh"
    runs-on: ubuntu-latest
    needs: [create-argocd-app]
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3

    - name: Configure HUB cluster kubeconfig
      run: |
        aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub
        kubectl config use-context hub

    - name: Trigger ArgoCD hard refresh
      run: |
        APP_NAME_FULL="${APP_NAME}-${ENVIRONMENT}"

        # Patch application to trigger hard refresh
        kubectl patch application ${APP_NAME_FULL} -n argocd \
          --type merge \
          --patch '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'

        echo "‚úì ArgoCD hard refresh triggered for ${APP_NAME_FULL}"

  # ============================================================================
  # STAGE 9: ARGOCD SYNC (HUB Cluster)
  # ============================================================================
  argocd-sync:
    name: "Stage 9: Sync ArgoCD Application"
    runs-on: ubuntu-latest
    needs: [argocd-refresh]
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3

    - name: Configure HUB cluster kubeconfig
      run: |
        aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub
        kubectl config use-context hub

    - name: Trigger sync and wait
      run: |
        APP_NAME_FULL="${APP_NAME}-${ENVIRONMENT}"

        # Trigger sync
        kubectl patch application ${APP_NAME_FULL} -n argocd \
          --type merge \
          --patch '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"syncStrategy":{"hook":{}}}}}'

        echo "Waiting for sync to complete..."

        # Wait for sync (max 5 minutes)
        for i in {1..60}; do
          SYNC_STATUS=$(kubectl get application ${APP_NAME_FULL} -n argocd \
            -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")

          HEALTH_STATUS=$(kubectl get application ${APP_NAME_FULL} -n argocd \
            -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")

          echo "Sync: ${SYNC_STATUS}, Health: ${HEALTH_STATUS}"

          if [ "$SYNC_STATUS" = "Synced" ] && [ "$HEALTH_STATUS" = "Healthy" ]; then
            echo "‚úì Application synced and healthy"
            exit 0
          fi

          if [ "$HEALTH_STATUS" = "Degraded" ]; then
            echo "‚ùå Application health is degraded"
            kubectl get application ${APP_NAME_FULL} -n argocd -o yaml
            exit 1
          fi

          sleep 5
        done

        echo "‚ö†Ô∏è  Sync did not complete within timeout"
        kubectl get application ${APP_NAME_FULL} -n argocd -o yaml
        exit 1

  # ============================================================================
  # STAGE 10: VERIFY DEPLOYMENT (SPOKE Cluster)
  # ============================================================================
  verify-deployment:
    name: "Stage 10: Verify Deployment"
    runs-on: ubuntu-latest
    needs: [argocd-sync]
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3

    - name: Configure SPOKE cluster kubeconfig
      run: |
        aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke
        kubectl config use-context spoke

    - name: Verify pods are running
      run: |
        echo "Checking deployment status..."
        kubectl get deployment ${APP_NAME} -n ${NAMESPACE} || true

        echo "Waiting for pods to be ready..."
        kubectl wait --for=condition=available --timeout=300s \
          deployment/${APP_NAME} -n ${NAMESPACE}

        echo "‚úì Deployment verified"

    - name: Show pod status
      if: always()
      run: |
        kubectl get pods -n ${NAMESPACE}
        kubectl describe deployment ${APP_NAME} -n ${NAMESPACE}

    - name: Test application endpoint
      run: |
        APP_URL="https://${APP_NAME}-${ENVIRONMENT}.${DOMAIN}"
        echo "Testing endpoint: ${APP_URL}"

        for i in {1..12}; do
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${APP_URL} || echo "000")
          echo "HTTP Status: ${HTTP_CODE}"

          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úì Application is accessible"
            exit 0
          fi

          echo "Waiting for application... (attempt $i/12)"
          sleep 10
        done

        echo "‚ö†Ô∏è  Application endpoint not responding with 200"
        exit 0  # Don't fail deployment if endpoint check fails

  # ============================================================================
  # STAGE 11: DEPLOYMENT LANDSCAPE (Dashboard & S3 Hub Publish)
  # ============================================================================
  deployment-landscape:
    name: "Stage 11: Deployment Landscape"
    runs-on: ubuntu-latest
    needs: [verify-deployment]
    if: always() && needs.verify-deployment.result == 'success'
    permissions:
      contents: read

    steps:
    - name: Deployment Summary
      run: |
        echo "# Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "‚úÖ **Deployment Successful**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
        echo "| Application | ${APP_NAME} |" >> $GITHUB_STEP_SUMMARY
        echo "| Environment | ${ENVIRONMENT} |" >> $GITHUB_STEP_SUMMARY
        echo "| Image Tag | ${{ needs.build-image.outputs.image_tag }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Namespace | ${NAMESPACE} |" >> $GITHUB_STEP_SUMMARY
        echo "| Cluster | ${SPOKE_CLUSTER} |" >> $GITHUB_STEP_SUMMARY
        echo "| URL | https://${APP_NAME}-${ENVIRONMENT}.${DOMAIN} |" >> $GITHUB_STEP_SUMMARY
        echo "| ArgoCD | https://${ARGOCD_SERVER} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Pipeline Duration:** ~12-13 minutes" >> $GITHUB_STEP_SUMMARY

    - name: Deployment complete
      run: |
        echo "üéâ Deployment complete!"
        echo ""
        echo "Application URL: https://${APP_NAME}-${ENVIRONMENT}.${DOMAIN}"
        echo "ArgoCD Dashboard: https://${ARGOCD_SERVER}"
